# 04.游戏引擎中的渲染实践

![渲染管线](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled.png)

渲染管线

## 了解GPU

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%201.png)

SIMD:单指令多数据运算（一个加法指令，同时计算$xyzw$，例如：矩阵，坐标变换……）

SIMT:单指令多线程运算（一个核做得很小，一次能算“100”个）做运算尽可能用同样的代码，分别访问不同的数据

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%202.png)

GPC：图形处理集群    SM：流处理器

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%203.png)

“数据在计算机间流动是有成本的”尽可能传递单向数据

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%204.png)

“缓存Cache对计算机性能的影响远超想象”

## 可渲染物体

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%205.png)

插值计算法线方向在折线处会出问题，所以要单独定义每个顶点的法线方向

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%206.png)

Mesh分解为Submesh子模型用于区分模型对应不同的材质

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%207.png)

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%208.png)

现代游戏中有许多内容使用是重复共用的（例如大量的群集士兵），这时主流做法是建立一个POOL，把需要的Mesh、Shader、Texture存储在一起统一调用，这便是运用Instance实例化。

Instance实例化这个理念并不只用于渲染，而是贯穿整个游戏引擎。

GPU批量渲染GPU Batch Rendering

## 可视化裁剪

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%209.png)

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2010.png)

通过Bounding Box检测各个顶点是否在视锥体之内决定是否要绘制

![各种形式的包围盒Bounding Box，Sphere效率最高](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2011.png)

各种形式的包围盒Bounding Box，Sphere效率最高

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2012.png)

四叉树划分结合Bounding Box判断

“该区域最大的物体是否在视锥体内，不在则不用绘制，在的话进一步划分”

![BVH](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2013.png)

BVH

![PVS 潜在可见性设置](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2014.png)

PVS 潜在可见性设置

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2015.png)

站在7号房间观察只需要渲染6123房间

## 纹理压缩

![游戏引擎使用的的纹理都会被压缩](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2016.png)

游戏引擎使用的的纹理都会被压缩

在游戏引擎的绘制里面不能使用类似BMP等优秀的压缩算法，因为这些算法不能随机访问，计算复杂度高。普遍使用block-based算法。

![block-based算法](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2017.png)

block-based算法

取像素中的最大值和最小值，通过距离关系利用插值近似表达颜色

## 建模工具

![点线面、卡线、由粗到细](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2018.png)

点线面、卡线、由粗到细

![Zbrush雕刻型工具](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2019.png)

Zbrush雕刻型工具

![扫描](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2020.png)

扫描

![程序化建模](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2021.png)

程序化建模

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2022.png)

 

## 基于集群的模型管线（现代模型管线）

![雕刻工具创造无数的细节](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2023.png)

雕刻工具创造无数的细节

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2024.png)

面对一个极为精细的模型时，拆分成每一个小Mesh，再计算，此时计算是完全一致的（实例化？批处理？）

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2025.png)

Mesh Shader核心想法：通过一个算法基于数据凭空生成很多几何，可以根据距离相机的远近选择精度；优势在于可以创作无数的细节。

![基于集群的GPU裁剪 GPU Culling in Cluster-Based Mesh](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Training-Day.gif)

基于集群的GPU裁剪 GPU Culling in Cluster-Based Mesh

![Untitled](04%20%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5/Untitled%2026.png)

UE5的Nanite则是基于集群的GPU裁剪更往前了一步

**要记住的**

1. 游戏引擎的工程系统深度依赖现代图形硬件的理解；
2. 模型材质之间的关系（Mesh、SubMesh）；
3. 尽可能通过运算把绘制的东西减到越少越好，把性能释放刀最大；
4. 把较多的工作给GPU来分担CPU的负担