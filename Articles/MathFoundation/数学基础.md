# 第4章 数学基础

[旋转矩阵的几何意义解释_x264.mp4](%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E9%87%8A_x264.mp4)

# 左手坐标系和右手坐标系

为什么在三维笛卡儿坐标系中要区分左手坐标系和右手坐标系，而二维中就没有这些烦人的事情呢？这是因为，在二维笛卡儿坐标系中， x 轴和y 轴的指向虽然可能不同，就如我们在图4.4中看到的一样。但我们总可以通过一些旋转操作来使它们的坐标轴指向相同。

从这种意义上来说，所有的二维笛卡儿坐标系都是等价的。

![Untitled](Untitled.png)

但对于三维笛卡儿坐标系，靠这种旋转有时并不能使两个不同朝向的坐标系重合。例如，在图4. 6 中， +z 轴的方向指向纸面的内部，如果有另一个三维笛卡儿坐标系，它的+z 轴指向纸面外部， x 轴和y 轴保持不变，那么我们可以通过旋转把这两个坐标轴重合在一起吗？答案是否定的。我们总可以让其中两个坐标轴的指向重合，但第三个坐标轴的指向总是相反的。

也就是说， 三维笛卡尔坐标系并不都是等价的。

因此，就出现了两种不同的三维坐标系： 左手坐标系和右手坐标系。

![Untitled](Untitled%201.png)

![Untitled](Untitled%202.png)

除了坐标轴朝向不同之外，左手坐标系和右手坐标系对千正向旋转的定义也不同，即在初高
中物理中学到的**左手法则(left-band rule)** 和**右手法则(right-band rule)** 。

![Untitled](Untitled%203.png)

我们可以分别在一个左手坐标系和右手坐标系中描述这样一次运动， 即使用数学表达式来描
述它。我们会发现，在不同的坐标系中描述这样同一次运动是不一样的，如图4.11 所示。

![Untitled](Untitled%204.png)

为了达到同样的视觉效果，左右手坐标系在z 轴上的**移动**以及**旋转方向**是不同的。

# 点和矢量

**点(point)** 是n 维空间（游戏中主要使用二维和三维空间）中的一个位置， 它没有大小、宽度这类概念。

**矢量(vector, 也被称为向量）**的定义则复杂一些。矢量是指n 维空间中一种包含了**模(magnitude)** 和**方向(direction)** 的有向线段。

- 矢量的模指的是这个矢量的长度。一个矢量的长度可以是任意的非负数。
- 矢量的方向则描述了这个矢量在空间中的指向。
- 矢量的表示方法和点类似。我们可以使用v=(x,y)来表示二维矢拯，用v=(x,y,z)来表示三维矢
量，用v=(x,y,z,w)来表示四维矢量。

通常，矢量被用于表示相对于某个点的**偏移(displacement)**, 也就是说它是一个相对量。只要矢量的模和方向保持不变， 无论放在哪里，都是同一个矢量。

矢量通常用千描述偏移扯，因此，它们可以用千描述相对位置，即相对于另一个点的位置，此时矢量的尾是一个位置，那么矢量的头就可以表示另一个位置了。而一个点可以用于指定空间中的一个位置（即相对于原点的位置） 。如果我们把矢量的尾固定在坐标系原点， 那么这个矢量的表示就和点的表示重合了。图4.16表示了两者之间的关系。

![Untitled](Untitled%205.png)

为了方便阐述，我们对不同类型的变量在书写和印刷上使用不同的样式。

- 对于标量，我们使用小写字母来表示，如a, b, x, y, z, θ, α等。
- 对于矢量， 我们使用小写的粗体字母来表示，如**a, b, u, v**等。
- 对于后面要学习的矩阵，我们使用大写的粗体字母来表示，如**A, B, S, M, R** 等。

## 矢量和标量的乘法／除法

标量是只有模没有方向的童， 虽然我们不能把矢量和标盘进行相加/相减的运算（想象一下， 你会把速度和距离相加吗）， 但可以对它们进行乘法运算， 结果会得到一个不同长度且可能方向相反的新的矢量。

![Untitled](Untitled%206.png)

注意， 对于乘法来说， 矢量和标量的位置可以互换。但对于除法， 只能是矢量被标量除， 而不能是标量被矢量除， 这是没有意义的。

## 矢量的加法和减法

我们可以对两个矢量进行相加或相减， 其结果是一个**相同维度**的新矢量。

需要注意的是，一个矢量不可以和一个标量相加或相减，或者是和**不同维度**的矢量进行运算。

从几何意义上来看， 对于加法， 我们可以把矢量a 的头连接到矢量b的尾， 然后画一条从a的尾到b的头的矢量， 来得到a和b相加后的矢量。也就是说， 如果我们从一个起点开始进行了一个位置偏移a, 然后又进行一个位置偏移b, 那么就等同于进行了一个a+b的位置偏移。这被称为矢量加法的**三角形定则(triangle rule)** 。矢量的减法是类似的，如图4.18 所示。

![Untitled](Untitled%207.png)

## 矢量的模

正如我们之前讲到的一样，矢量是有模和方向的。矢量的模是一个标量，可以理解为是矢量在空间中的长度。它的表示符号通常是在矢量两旁分别加上一条垂直线（有的文献中会使用两条垂直线）。

三维矢量的模的计算公式如下：

$|v|=\sqrt{{v_x^2+v_y^2+v_z^2}}$

其他维度的矢量的模计算类似，都是对每个分量的平方相加后再开根号得到。

$|(1,2,3)|=\sqrt{{1^2+2^2+3^2}}=\sqrt{1+4+9}=\sqrt{14}≈3.742$

$|(3,4)|=\sqrt{{3^2+4^2}}=\sqrt{9+16}=\sqrt{25}=5$

我们可以从几何意义来理解上述公式。对于二维矢量来说，我们可以对任意矢量构建一个三角形，如图4.20 所示。

![Untitled](Untitled%208.png)

从图4.20 可以看出，对于二维矢量，其实就是使用了**勾股定理**，矢量的两个分量的绝对值对应了三角形两个直角边的长度，而斜边的长度就是矢量的模。

## 单位矢量

**在很多情况下，我们只关心矢量的方向而不是模。**

单位矢量指的是那些模为1的矢量。单位矢量也被称为**被归一化的矢量(normalized vector)**。对任何给定的非零矢量，把它转换成单位矢量的过程就被称为**归一化(normalization)**。

为了对矢量进行归一化，我们可以用矢量除以该矢量的模来得到。公式如下：

**$\hat{v} = \frac {v}{|v|}$**

零矢量（即矢量的每个分量值都为0, 如v=(0,0,0)) 是不可以被归一化的。这是因为做除法运算时分母不能为0。

## 矢量的点积

矢量之间也可以进行乘法，但是和标量之间的乘法有很大不同。矢量的乘法有两种最常用的种类：**点积(dot product, 也被称为内积，inner product)** 和**叉积(cross product, 也被称为外积， outer product)**。

公式一：$a\cdot b=(a_x,a_y,a_z)\cdot (b_x,b_y,b_z)=a_x b_x+a_y b_y+a_y b_y$

点积的符号可以让我们知道两个矢量的方向关系。

![Untitled](Untitled%209.png)

这意味着， 我们可以直接利用点积来求矢量的模， 而不需要使用模的计算公式。 当然， 我们需要对点积结果进行开平方的操作来得到真正的模。 但很多情况下， 我们只是想要比较两个矢量的长度大小， 因此可以直接使用点积的结果。 毕竟， 开平方的运算需要消耗一定性能。

![Untitled](Untitled%2010.png)

## 矢量的叉积

另一个重要的矢量运算就是**叉积(cross product), 也被称为外积(outer product)**。与点积不同的是， 矢量叉积的结果仍是一个矢量， 而非标量。

需要注意的是，叉积不满足交换律， 即$a*b \ne b*a$ 。实际上，叉积是满足反交换律的，即$a*b=-(b*a)$ 。而且叉积也不满足结合律，即$(a*b)*c \ne a*(b*c)$ 。

我们先来看它的模。$a*b$ 的长度等于a 和b 的模的乘积再乘以它们之间夹角的正弦值。公式如下：

|$a*b|=|a||b|sin\theta$

如图4.26 所示，我们使用a 和b 构建一个平行四边形。

我们知道，平行四边形的面积可以使用$|b|h$ 来得到，即底乘以高。而$h$又可以使用间和夹角θ来得到，即

**$A=|b|h=|b|(|a|sin\theta)=|a||b|sin\theta=|a*b|$**

你可能会问，如果a 和b 平行（可以是方向完全相同，也可以是完全相反）怎么办，不就不能构建平行四边形了吗？我们可以认为构建出来的平行四边形面积为0 , 那么$a*b=0$ 。注意，这里得到的是零向量，而不是标量0 。

下面，我们来看结果矢量的方向。你可能会说：“方向？不是已经说了方向了嘛，就是和两个矢量都垂直就可以了啊。”但是，如果你仔细想一下就会发现， 实际上我们有两个方向可以选择，这两个方向都和这两个矢量垂直。那么，我们要选择哪个方向呢？
这里就要和之前提到的左手坐标系和右手坐标系联系起来了，如图4.27 所示。

这个结果是怎么得到的呢？来， 举起你的双手！ 哦，不……先举起你的右手。在右手坐标系中，$a*b$ 的方向将使用右手法则来判断。我们先想象把手心放在了a 和b 的尾部交点处，然后张开你的手掌让手掌方向和a 的方向重合，再弯曲你的四指让它们向b的方向靠拢，最后伸出你的大拇指！ 大拇指指向的方向就是右手坐标系中$a*b$ 的方向了。如果你实在不明白怎么摆放和扭动
你的手，那么就看图4.28 好了。

![Untitled](Untitled%2011.png)

![Untitled](Untitled%2012.png)

![Untitled](Untitled%2013.png)

需要注意的是， 虽然看起来左右手坐标系的选择会影响叉积的结果， 但这仅仅是“看起来” 而已。从叉积的数学表达式可以发现， 使用左手坐标系还是右手坐标系不会对计算结果产生任何影响， 它影响的只是数字在三维空间中的视觉化表现而已。当从右手坐标系转换为左手坐标系时， 所有点和矢量的表达和计算方式都会保持不变，只是当呈现到屏幕上时，我们可能会发现，＇｀咦，怎么图像反过来了！ ”。当我们想要两个坐标系达到同样的视觉效果时， 可能就需要改变一些数学运算公式， 这不在本书的范畴内。有兴趣的读者可以参考本章的扩展阅读部分。

# 矩阵

定义：从它的外观上来看，就是一个长方形的网格，每个格子里放了一个数字。的确，矩阵就是这么简单： 它是由mXn 个标量组成的长方形数组。

$m_{ij}$ 表明了这个元素在矩阵$m$的第i 行、第j 列。

## 和矢量联系起来

我们可以用矩阵来表示矢量。实际上，**矢量可以看成是$n*1$ 的列矩阵(column matrix) 或$1*n$ 的行矩阵(row matrix)**, 其中n 对应了矢量的维度

矢量可以像一个矩阵一样一起参与矩阵运算。这在空间变换中将非常有用。

## 矩阵运算

### 矩阵和标量的乘法

和矢量类似，矩阵也可以和标量相乘，它的结果仍然是一个相同维度的矩阵。它们之间的乘法非常简单，就是矩阵的每个元素和该标量相乘。以3 x 3 的矩阵为例，其公式如下：

---

### 矩阵和矩阵的乘法

两个矩阵的乘法也很简单，它们的结果会是一个新的矩阵，并且这个矩阵的维度和两个原矩阵的维度都有关系。

**一个rXn 的矩阵A 和一个nXc 的矩阵B 相乘，它们的结果AB 将会是一个rXc 大小的矩阵。**请读者注意它们的行列关系，**第一个矩阵的列数必须和第二个矩阵的行数相同，它们相乘得到的矩阵的行数是第一个矩阵的行数，而列数是第二个矩阵的列数。**例如，如果矩阵A 的维度是4X3,矩阵B 的维度是3X6, 那么AB 的维度就是4X6 。

如果两个矩阵的行列不满足上面的规定这两个矩阵就不能相乘， 因为它们之间的乘法是没有被定义的。

![Untitled](Untitled%2014.png)

![注意：是矢量点乘的结果，点乘 点乘 点乘](Untitled%2015.png)

注意：是矢量点乘的结果，点乘 点乘 点乘

解释：对于每个元素$C_{ij}$, 我们找到$A$ 中的第$i$行和$B$ 中的第$j$列，然后把它们的对应元素相乘后再加起来，这个和就是$C_{ij}$

---

**案例:**

一种更直观的方式如图4.30 所示。假设$A$ 的大小是4x2, $B$ 的大小是2x4, 那么如果要计算$C$的元素$c_{23}$ 的话，先找到对应的行矩阵和列矩阵，即
$A$ 中的第2 行和$B$ 中的第3 列，把它们进行**矢量点积**后就可以得到结果值。因此，$c_{23}=a_{21}\cdot b_{13}+a_{22}\cdot b_{23}$

![Untitled](Untitled%2016.png)

![Untitled](Untitled%2017.png)

## 特殊的矩阵

### 方块矩阵(square matrix)

![Untitled](Untitled%2018.png)

### 单位矩阵(identity matrix)

![Untitled](Untitled%2019.png)

### 转置矩阵(transposed matrix)

![Untitled](Untitled%2020.png)

![Untitled](Untitled%2021.png)

### 逆矩阵(inverse matrix)

不是所有的矩阵都有逆矩阵，第一个前提就是，该矩阵必须是一个方阵。

![Untitled](Untitled%2022.png)

![Untitled](Untitled%2023.png)

![Untitled](Untitled%2024.png)

### 正交矩阵(orthogonal matrix)

![Untitled](Untitled%2025.png)

![Untitled](Untitled%2026.png)

**在Unity 中，常规做法是把矢量放在矩阵的右侧，即把矢量转换成列矩阵来进行运算。**

# 矩阵的几何意义：变换

## 什么是变换

我们先来看一个非常常见的变换类型一**线性变换(linear transform)**。线性变换指的是那些可以保留**矢量加**和**标量乘**的变换。用数学公式来表示这两个条件就是：

$f(x)+f(y)=f(x+y)$

$kf(x)=f(kx)$

**仿射变换(affine transform)** 。仿射变换就是合并线性变换和平移变换的变换类型。仿射变换可以使用一个4x4的矩阵来表示，为此，我们需要把矢量扩展到四维空间下，这就是**齐次坐标空间(homogeneous space) 。**

例如$f(x)=x+(1,2,3)$。这个变换就不是一个线性变换，它既不满足标量乘法，也不满足矢量加法。如果我们令$x=(1,1,1)$,那么：

$f(x)+f(x)=(4,6,8)$

$f(x+x)=(3,4,5)$

![Untitled](Untitled%2027.png)

## 齐次坐标

由于3X3 矩阵不能表示平移操作，我们就把其扩展到了4 X4 的矩阵（是的，只要多一个维度就可以实现对平移的表示）。为此，我们还需要把原来的三维矢量转换成四维矢量，也就是我们所说的**齐次坐标(homogeneous coordinate)**

对于一个*点*，从三维坐标转换成齐次坐标是把其$w$ 分量设为$1$, 而对于*方向矢量*来说，需要把其$w$ 分量设为$0$。这样的设置会导致，**当用一个4x4 矩阵对一个点进行变换时，平移、旋转、缩放都会施加于该点。但是如果是用于变换一个方向矢量，平移的效果就会被忽略。**

### 分解基础变换矩阵

我们把表示纯平移、纯旋转和纯缩放的变换矩阵叫做基础变换矩阵。这些矩阵具有一些共同点，我们可以把一个基础变换矩阵分解成4 个组成部分：

其中，左上角的矩阵$M_{3x3}$ 用于表示旋转和缩放， $t_{3x1}$ 用于表示平移， $0_{1x3}$ 是零矩阵， 即$0_{1x3}=[0 \quad0\quad0]$,右下角的元素就是标量1。

![基础变换矩阵](Untitled%2028.png)

基础变换矩阵

### 平移矩阵

我们可以使用矩阵乘法来表示对一个点进行平移变换：

从结果来看我们可以很容易看出为什么这个矩阵有平移的效果： 点的$x 、y 、z$ 分址分别增加了一个位置偏移。在3D 中的可视化效果是，把点$(x,y,z)$在空间中平移了$(t_x,t_y,t_z)$个单位。

![Untitled](Untitled%2029.png)

---

有趣的是，如果我们对一个方向矢量进行平移变换，结果如下：

可以发现，平移变换不会对方向矢量产生任何影响。这点很容易理解，我们在学习矢量的时候就说过了，矢量没有位置属性，也就是说它可以位于空间中的任意一点，因此对位置的改变（即平移）不应该对四维矢量产生影响。

![Untitled](Untitled%2030.png)

---

平移矩阵的逆矩阵就是反向平移得到的矩阵，即

可以看出，平移矩阵并不是一个正交矩阵。

![Untitled](Untitled%2031.png)

### 缩放矩阵

我们可以对一个模型沿空间的$x 轴、y轴和z轴$进行缩放。同样，我们可以使用矩阵乘法来表示一个缩放变换：

![Untitled](Untitled%2032.png)

对方向矢量可以使用同样的矩阵进行缩放：

![Untitled](Untitled%2033.png)

如果缩放系数$k_x=k_y=k_z$, 我们把这样的缩放称为**统一缩放(uniform scale)**, 否则称为**非统一缩放(nonuniform scale)** 。

统一缩放不会改变角度和比例信息，而非统一缩放会改变与模型相关的角度和比例。例如在对法线进行变换时，如果存在非统一缩放，直接使用用于变换顶点的变换矩阵的话，就会得到错误的结果。正确的变换方法可参见4.7 节。

缩放矩阵的逆矩阵是使用原缩放系数的倒数来对点或方向矢量进行缩放，即

![Untitled](Untitled%2034.png)

缩放矩阵一般不是正交矩阵。
上面的矩阵只适用于沿坐标轴方向进行缩放。如果我们希望在任意方向上进行缩放，就需要使用一个复合变换。其中一种方法的主要思想就是，先将缩放轴变换成标准坐标轴，然后进行沿坐标轴的缩放，再使用逆变换得到原来的缩放轴朝向。

### 旋转矩阵

旋转是三种常见的变换矩阵中最复杂的一种。我们知道，旋转操作需要指定一个旋转轴，这个旋转轴不一定是空间中的坐标轴，但本节所讲的旋转就是指绕着空间中的$x 轴、y 轴或z 轴$进行旋转。

如果我们需要把点绕着$x$ 轴旋转$\theta$度，可以使用下面的矩阵：

![Untitled](Untitled%2035.png)

绕$y$ 轴的旋转也是类似的：

![Untitled](Untitled%2036.png)

最后，是绕z 轴的旋转：

![Untitled](Untitled%2037.png)

旋转矩阵的逆矩阵是旋转相反角度得到的变换矩阵。旋转矩阵是正交矩阵， 而且多个旋转矩阵之间的串联同样是正交的。

### 复合变换

我们可以把平移、旋转和缩放组合起来， 来形成一个复杂的变换过程。例如， 可以对一个模型先进行大小为(2, 2, 2)的缩放， 再绕y 轴旋转30° , 最后向z轴平移4 个单位。

复合变换可以通过矩阵的串联来实现。上面的变换过程可以使用下面的公式来计算：

**$P_{new}=M_{translation}M_{rotation}M_{scale}P_{old}$**

由于上面我们使用的是列矩阵， 因此阅读顺序是从右到左， 即先进行缩放变换， 再进行旋转变换， 最后进行平移变换。需要注意的是， 变换的结果是依赖千变换顺序的， 由于矩阵乘法不满足交换律， 因此矩阵的乘法顺序很重要。

在绝大多数情况下， 我们约定变换的顺序就是先缩放， 再旋转， 最后平移。

![Untitled](Untitled%2038.png)

为了从数学公式上理解变换顺序的本质， 我们可以对比不同变换顺序产生的变换矩阵的表达式。如果我们只考虑对y轴的旋转的话， 按先缩放、再旋转、最后平移这样的顺序组合3种变换得到的变换矩阵是：

![Untitled](Untitled%2039.png)

而如果我们使用了其他变换顺序， 例如先平移， 再缩放， 最后旋转， 那么得到的变换矩阵是：

![Untitled](Untitled%2040.png)

当我们直接给出（$\theta_x,\theta_y,\theta_z）$这样的旋转角度时， 需要定义一个旋转顺序。在Unity中， 这个旋转顺序是$zxy$, 这在旋转相关的API文档中都有说明。这意味着， 当给定$（\theta_x,\theta_y,\theta_z）$这样的旋转角度时， 得到的组合旋转变换矩阵是：

![Untitled](Untitled%2041.png)

一些读者会有疑问： 上面的公式书写顺序是不是反了？不是说列矩阵要从右往左读吗？这样一来顺序不就颠倒了吗？实际上， 有一个非常重要的东西我们没有说明白， 那就是旋转时使用的坐标系。给定一个旋转顺序（例如这里的$zxy$), 以及它们对应的旋转角度$（\theta_x,\theta_y,\theta_z）$, 有两种坐标系可以选择。

- 绕坐标系$E$下的$z$轴旋转$\theta_z$ , 绕坐标系$E$下的$y$轴旋转$\theta_y$, 绕坐标系$E$下的$x$轴旋转$\theta_x$ ,即进行一次旋转时不一起旋转当前坐标系。
- 绕坐标系$E$下的$z$轴旋转岛在坐标系E下再绕z轴旋转$\theta_z$ 后的新坐标系$E'$下的$y$轴旋转$\theta_y$, 在坐标系E$'$下再绕$y$轴旋转$\theta_y$后的新坐标系$E"$下的$x$轴旋转$\theta_x$ , 即在旋转时，把坐标系一起转动。

很容易知道， 这两种选择的结果是不一样的。**但如果把它们的旋转顺序颠倒一下， 它们得到的结果就会是一样的！**说得明白点，在第一种情况下，按$zxy$顺序旋转和在第二种情况下，按$yxz$顺序旋转是一样的。而Unity文档中说明的旋转顺序指的是在第一种情况下的顺序。

---

## 坐标空间

### 为什么要使用这么多不同的坐标空间

我们需要在不同的情况下使用不同的坐标空间， **因为一些概念只有在特定的坐标空间下才有意义**， 才更容易理解。这也是为什么在渲染中我们要使用这么多坐标空间。

![Untitled](Untitled%2042.png)

### 坐标空间的变换

我们先要为后面的内容做些数学铺垫。在渲染流水线中，我们往往需要把一个点或方向矢量从一个坐标空间转换到另一个坐标空间。这个过程到底是怎么实现的呢？

我们把问题一般化。我们知道，要想定义一个坐标空间，必须指明其原点位置和3 个坐标轴的方向。而**这些数值实际上是相对于另一个坐标空间的（读者需要记住，所有的都是相对的）** 。也就是说，坐标空间会形成一个层次结构——**每个坐标空间都是另一个坐标空间的子空间**，反过来说，**每个空间都有一个父(parent) 坐标空间**。对坐标空间的变换实际上就是在父空间和子空间之间对点和矢量进行变换。

假设，现在有父坐标空间$P$ 以及一个子坐标空间$C$ 。我们知道在父坐标空间中子坐标空间的原点位置以及3个单位坐标轴。我们一般会有两种需求： 一种需求是把子坐标空间下表示的点或矢量$A_c$ 转换到父坐标空间下的表示$A_p$, 另一个需求是反过来， 即把父坐标空间下表示的点或矢量$B_p$转换到子坐标空间下的表示$B_c$。我们可以使用下面的公式来表示这两种需求：

$A_p=M_{c→p}A_c$

$B_c=M_{p→c}B_p$

其中， $M_{c-p}$ 表示的是从子坐标空间变换到父坐标空间的变换矩阵，而$M_{p→c}$ 是其逆矩阵（即反向变换）。

![Untitled](Untitled%2043.png)

![Untitled](Untitled%2044.png)

需要注意的是，这里我们并没有要求3 个坐标轴$X_c、Y_c$ 和$Z_c$ 是单位矢量，事实上，如果存在缩放的话，这3 个矢量值很可能不是单位矢量。

我们可以利用反向思维，从这个变换矩阵反推来获取子坐标空间的原点和坐标轴方向！

例如，当我们已知从模型空间到世界空间的一个4x4 的变换矩阵，可以提取它的第一列再进行**归一化**后（为了消除缩放的影响）来得到模型空间的$x$ 轴在世界空间下的单位矢量表示。同样的方法可以提取$y$ 轴和$z$ 轴。我们可以从另一个角度来理解这个提取过程。因为矩阵$M_{c→p}$可以把一个方向矢量从坐标空间$C$ 变换到坐标空间$P$ 中，那么，我们只需要用它来变换坐标空间$C$ 中的$x$ 轴$(1,0,0,0)$, 即使用矩阵乘法$M_{c→p}[1 \quad 0 \quad 0 \quad 0]^T$, 得到的结果正是$M_{c→p}$ 的第一列。

另一个有趣的情况是，对方向矢量的坐标空间变换。我们知道，**矢量是没有位置的，因此坐标空间的原点变换是可以忽略的。也就是说，我们仅仅平移坐标系的原点是不会对矢量造成任何影响的。那么，对矢量的坐标空间变换就可以使用3X3 的矩阵来表示**，因为我们不需要表示平移变换。那么变换矩阵就是：

![Untitled](Untitled%2045.png)

在Shader中，我们常常会看到截取变换矩阵的前3行前3列来对法线方向、光照方向来进行空间变换，这正是原因所在。

![Untitled](Untitled%2046.png)

![Untitled](Untitled%2047.png)

![Untitled](Untitled%2048.png)

当你不知道把坐标轴的表示是按行放还是按列放的时候，不妨先选择一种摆放方式来得到变换矩阵。例如，现在我们想把一个矢拔从坐标空间$A$变换到坐标空间$B$, 而且我们已经知道坐标空间$B$的$x$ 轴、$y$ 轴、$z$ 轴在空间$A$下的表示，即$X_b 、Y_b$ 和$Z_b$。那么想要得到从$A$ 到$B$ 的变换矩阵$M_{A→B}$， 我们是把它们按列放呢还是按行放呢？**如果读者实在想不起来正确答案，我们不妨先随便选择一种方式**，例如按列摆放。那么，

![Untitled](Untitled%2049.png)

### 顶点的坐标空间变换过程

我们知道，**在渲染流水线中， 一个顶点要经过多个坐标空间的变换才能最终被画在屏幕上**。一个顶点最开始是在模型空间（见4.6.4 节）中定义的，最后它将会变换到屏幕空间中，得到真正的屏幕像素坐标。因此， 接下来的内容我们将解释顶点要进行的各种空间变换的过程。

在我们的农场游戏中， 妞妞很好奇自己是如何被渲染到屏幕上的。它只知道自己和一群小伙伴在农场里快乐地吃草， 而前面有一个摄像机一直在观察它们， 如图4.31 所示。妞妞特别喜欢自己的鼻子，它想知道鼻子是怎么被画到屏幕上的？

![Untitled](Untitled%2050.png)

在下面的内容中， 我们将了解妞妞的鼻子是如何一步步画到屏幕上的。

### 模型空间

**模型空间(model space)**, 如它的名字所暗示的那样，是和某个模型或者说是对象有关的。有时模型空间也被称为**对象空间(object space)** 或**局部空间(local space)** 。每个模型都有自己独立的坐标空间，当它移动或旋转的时候， 模型空间也会跟着它移动和旋转。把我们自己当成游戏中的模型的话，当我们在办公室里移动时， 我们的模型空间也在跟着移动，当我们转身时， 我们本身的前后左右方向也在跟着改变。

Unity 在模型空间中使用的是左手坐标系， 因此在模型空间中，$+x$ 轴、$+y$ 轴、$+z$ 轴分别对应的是模型的右、上和前向。需要注意的是，模型坐标空间中的$x$ 轴、$y$ 轴、$z$ 轴和自然方向的对应不一定是上述这种关系， 但由于Unity使用的是这样的约定，因此本书将使用这种方式。

当我们把妞妞放到场景中时，就会有一个模型坐标空间时刻跟随着它。妞妞鼻子的位置可以通过访问顶点属性来得到。假设这个位置是(0, 2,4), 由千顶点变换中往往包含了平移变换， 因此需要把其扩展到齐次坐标系下，得到顶点坐标是(0,2,4, 1), 如图4.32 所示。

![Untitled](Untitled%2051.png)

### 世界空间

**世界空间(world space)** 是一个特殊的坐标系，因为它建立了我们所关心的最大的空间。

在Unity 中，世界空间同样使用了左手坐标系。但它的$x$ 轴、$y$ 轴、$z$ 轴是固定不变的。在Unity 中，我们可以通过调整Transform 组件中的Position 属性来改变模型的位置，这里的位置值是相对于这个Transform 的**父节点(parent)** 的模型坐标空间中的原点定义的。如果一个Transform没有任何父节点，那么这个位置就是在世界坐标系中的位置， 如图4. 33 所示。我们可以想象成还有一个虚拟的根模型，这个根模型的模型空间就是世界空间，所有的游戏对象都附属于这个根模型。同样， Transform 中的Rotation 和Scale 也是同样的道理。

顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做**模型变换(model transform) 。**

现在，我们来对妞妞的鼻子进行模型变换。为此，我们首先需要知道妞妞在世界坐标系中进行了哪些变换， 这可以通过面板中的Transform 组件来得到相关的变换信息， 如图4.34 所示。

![Untitled](Untitled%2052.png)

根据Transform 组件上的信息，我们知道在世界空间中，妞妞进行了$(2, 2, 2)$的缩放，又进行了$(0, 150, 0)$ 的旋转以及$(5, 0, 25)$ 的平移。注意这里的变换顺序是不能互换的，即**先进行缩放，再进行旋转， 最后是平移**。据此我们可以构建出模型变换的变换矩阵：

![Untitled](Untitled%2053.png)

现在我们可以用它来对妞妞的鼻子进行模型变换了：

也就是说， 在世界空间下， 妞妞鼻子的位置是$(9,4,18.072)$ 。注意， 这里的浮点数都是近似值，这里近似到小数点后3 位。实际数值和Unity 采用的浮点值精度有关。

![Untitled](Untitled%2054.png)

## 观察空间

**观察空间(view space) 也被称为摄像机空间(camera space)** 。观察空间可以认为是模型空间的一个特例－在所有的模型中有一个非常特殊的模型，即摄像机（虽然通常来说摄像机本身是不可见的），它的模型空间值得我们单独拿出来讨论，也就是观察空间。

摄像机决定了我们渲染游戏所使用的视角。在观察空间中，摄像机位于原点，同样，其坐标轴的选择可以是任意的，但由于本书讨论的是以Unity 为主，而Unity 中**观察空间**的坐标轴选择是： **+x 轴指向右方， +y 轴指向上方，而+z 轴指向的是摄像机的后方。**

读者在这里可能觉得很奇怪，我们之前讨论的模型空间和世界空间中+z 轴指的都是物体的前方，为什么这里不一样了呢？这是因为， Unity 在模型空间和世界空间中选用的都是**左手坐标系**，而在观察空间中使用的是右
**手坐标系**。这是符合OpenGL 传统的， 在这样的观察空间中，摄像机的正前方指向的是-z 轴方向。

最后要提醒读者的一点是，观察空间和屏幕空间（详见4.6.8 节）是不同的。观察空间是一个三维空间，而屏幕空间是一个二维空间。从观察空间到屏幕空间的转换需要经过一个操作， 那就是**投影(projection)** 。我们后面就会讲到。

顶点变换的第二步，就是将顶点坐标从世界空间变换到观察空间中。这个变换通常叫做**观察变换(view transform) 。**

回到我们的农场游戏。现在我们需要把妞妞的鼻子从世界空间变换到观察空间中。为此，我们需要知道世界坐标系下摄像机的变换信息。这同样可以通过摄像机面板中的Transform 组件得到，如图4.35 所示。

![Untitled](Untitled%2055.png)

为了得到顶点在观察空间中的位置，我们可以有两种方法。一种方法是计算观察空间的3个坐标轴在世界空间下的表示，然后根据4.6.2 节(坐标空间的变换)中讲到的方法，构建出从观察空间变换到世界空间的变换矩阵，再对该矩阵求逆来得到从世界空间变换到观察空间的变换矩阵。我们还可以使用另一种方法，即想象平移整个观察空间，让摄像机原点位于世界坐标的原点，坐标轴与世界空间中的坐标轴重合即可。这两种方法得到的变换矩阵都是一样的，不同的只是我们思考的方式。

这里我们使用第二种方法。由Transform组件可以知道，摄像机在世界空间中的变换是先按$(30,0,0)$进行旋转，然后按$(0, 10, -10)$进行了平移。那么，为了把摄像机重新移回到初始状态（这里指摄像机原点位于世界坐标的原点、坐标轴与世界空间中的坐标轴重合），我们需要进行逆向变换，即先按$(0, -10, 10)$平移，以便将摄像机移回到原点，再按$(-30, 0, 0)$进行旋转，以便让坐标轴蜇合。

因此，变换矩阵就是：

![Untitled](Untitled%2056.png)

## 裁剪空间

项点接下来要从观察空间转换到**裁剪空间(clip space, 也被称为齐次裁剪空间）**中， 这个用于变换的矩阵叫做**裁剪矩阵(clip matrix)**, 也被称为**投影矩阵(projection matrix)** 。

裁剪空间的目标是**能够方便地对渲染图元进行裁剪**： 完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。那么，这块空间是如何决定的呢？答案是由**视锥体(view frustum)** 来决定。

视锥体指的是空间中的一块区域，这块区域决定了摄像机可以看到的空间。视锥体由六个平面包围而成，这些平面也被称为**裁剪平面(clip planes)** 。视锥体有两种类型，这涉及两种投影类型： 一种是**正交投影(orthographic projection)**, 一种是**透视投影(perspective projection)** 。
图4.36 显示了从同一位置、同一角度渲染同一个场景的两种摄像机的渲染结果。

![Untitled](Untitled%2057.png)

从图中可以发现，在透视投影中，地板上的平行线并不会保持平行，离摄像机越近网格越大，离摄像机越远网格越小。而在正交投影中，所有的网格大小都一样， 而且平行线会一直保待平行。可以注意到，透视投影模拟了人眼看世界的方式，而正交投影则完全保留了物体的距离和角度。因此，在追求真实感的3D 游戏中我们往往会使用透视投影，而在一些2D 游戏或渲染小地图等其他HUD 元素时，我们会使用正交投影。

在视锥体的6 块裁剪平面中， 有两块裁剪平面比较特殊，它们分别被称为**近剪裁平面(near clip plane)** 和**远剪裁平面(far clip plane)** 。它们决定了摄像机可以看到的深度范围。正交投影和透视投影的视锥体如图4.3 7 所示。

![Untitled](Untitled%2058.png)

由图4.37 可以看出，透视投影的视锥体是一个金字塔形，侧面的4 个裁剪平面将会在摄像机处相交。它更符合视锥体这个词语。正交投影的视锥体是一个长方体。前面讲到，我们希望根据视锥体围成的区域对图元进行裁剪，但是，如果直接使用视锥体定义的空间来进行裁剪，那么不同的视锥体就需要不同的处理过程，而且对于透视投影的视锥体来说，想要判断一个顶点是否处于一个金字塔内部是比较麻烦的。因此，我们想用一种更加通用、方便和整洁的方式来进行裁剪的工作，这种方式就是**通过一个投影矩阵把顶点转换到一个裁剪空间中。**

**投影矩阵**有两个目的。

- 首先是为投影做准备。这是个迷惑点，虽然投影矩阵的名称包含了投影二字，但是它并没有进行真正的投影工作，而是在为投影做准备。真正的投影发生在后面的**齐次除法(homogeneous division)** 过程中。而经过投影矩阵的变换后，顶点的$w$ 分垃将会具有特殊的意义。

读者： 投影到底是什么意思呢？

我们： 可以理解成是一个空间的降维，例如从四维空间投影到三维空间中。而投影矩阵实际上并不会真的进行这个步骤，它会为真正的投影做准备工作。真正的投影会在屏幕映射时发生，通过齐次除法来得到二维坐标。具体会在4.6.8 节中讲到。

- 其次是对$x、y、z$ 分量进行缩放。我们上面讲过直接使用视锥体的6 个裁剪平面来进行裁剪会比较麻烦。而经过投影矩阵的缩放后，我们可以直接使用$w$ 分量作为一个范围值，如果$x 、y、z$ 分量都位于这个范围内，就说明该顶点位千裁剪空间内。

在裁剪空间之前，虽然我们使用了齐次坐标来表示点和矢量，但它们的第四个分量都是固定的：点的$w$ 分量是1, 方向矢量的$w$ 分量是0。经过投影矩阵的变换后，我们就会赋予齐次坐标的第4 个坐标更加丰富的含义。下面，我们来看一下两种投影类型使用的投影矩阵具体是什么。

### 1. 透视投影

视锥体的意义在于定义了场景中的一块三维空间。所有位于这块空间内的物体将会被渲染，否则就会被剔除或裁剪。我们已经知道，这块区域由6 个裁剪平面定义，那么这6 个裁剪平面又是怎么决定的呢？在Unity 中，它们由Camera 组件中的参数和Game 视图的横纵比共同决定，如图4.38 所示。

由图4.38 可以看出，我们可以通过Camera组件的Field of View (简称FOY) 属性来改变视锥体竖直方向的张开角度，而Clipping Planes 中的Near 和Far 参数可以控制视锥体的近裁剪平面和远裁剪平面距离摄像机的远近。这样，我们可以求出视锥体近裁剪平面和远裁剪平面的高度，也就是：

![Untitled](Untitled%2059.png)

$nearClipPlaneHeight=2*Near*tan\frac {FOV}{2}$

$farClipPlaneHeight=2*Far*tan\frac {FOV}{2}$

现在我们还缺乏**横向的信息**。这可以通过摄像机的横纵比得到。在Unity 中， 一个摄像机的横纵比由Game 视图的横纵比和Viewport Rect 中的W 和H 属性共同决定（实际上， Unity 允许我们在脚本里通过Camera.aspect 进行更改，但这里不做讨论）。假设，当前摄像机的横纵比为Aspect,我们定义：

$Aspect =  \frac{nearClipPlaneWidth}{nearClipPlaneHeight}$

$Aspect = \frac{farClipPlaneWidth}{farClipPlaneHeight}$

![Untitled](Untitled%2060.png)

从结果可以看出，这个投影矩阵本质就是对$x 、y$ 和$z$ 分量进行了不同程度的缩放（当然，$z$分量还做了一个平移），缩放的目的是为了方便裁剪。我们可以注意到，此时顶点的$w$ 分量不再是1, 而是原先$z$ 分量的取反结果。现在，我们就可以按如下不等式来判断一个变换后的顶点是否位于视锥体内。如果一个顶点在视锥体内，那么它变换后的坐标必须满足：

$-w≤x≤w$

$-w≤y≤w$

$-w≤z≤w$

任何不满足上述条件的图元都需要被剔除或者裁剪。图4.39 显示了经过上述投影矩阵后，视锥体的变化。

![Untitled](Untitled%2061.png)

从图4.39 还可以注意到，裁剪矩阵会改变空间的旋向性：空间从右手坐标系变换到了左手坐标系。这意味着，离摄像机越远，$z$ 值将越大。

### 2. 正交投影

首先，我们还是看一下正交投影中的6 个裁剪平面是如何定义的。和透视投影类似，在Unity中，它们也是由Camera 组件中的参数和Game 视图的横纵比共同决定，如图4.40 所示。

正交投影的视锥体是一个长方体， 因此计算上相比透视投影来说更加简单。由图可以看出，我们可以通过Camera 组件的Size 属性来改变视锥体竖直方向上高度的一半，而Clipping Planes 中的Near 和Far 参数可以控制视锥体的近裁剪平面和远裁剪平面距离摄像机的远近。这样，我们可以求出视锥体近裁剪平面和远裁剪平面的高度，也就是：

$nearClipPlaneHeight=2*Size$

$farClipPlaneHeight=nearClipPlaneHeight$

现在我们还缺乏横向的信息。同样，我们可以通过摄像机的横纵比得到。假设， 当前摄像机的横纵比为Aspect, 那么：

n$earClipPlane Width=Aspect·nearCIipPlaneHeight$

$farClipPlane Width=nearClipPlaneWidth$

![Untitled](Untitled%2062.png)

注意到，和透视投影不同的是，使用正交投影的投影矩阵对顶点进行变换后，其w 分量仍然为1 。本质是因为投影矩阵最后一行的不同，透视投影的投影矩阵的最后一行是$[0\quad 0\quad -1\quad  0]$, 而正交投影的投影矩阵的最后一行是$[0\quad 0\quad 0\quad 1]$ 。这样的选择是有原因的，是为了为齐次除法做准备。具体会在下一节中讲到。

判断一个变换后的顶点是否位于视锥体内使用的不等式和透视投影中的一样，这种通用性也是为什么要使用投影矩阵的原因之一。图4.41 显示了经过上述投影矩阵后，正交投影的视锥体的变化。
同样，**裁剪矩阵改变了空间的旋向性**。可以注意到，**经过正交投影变换后的顶点实际已经位于一个立方体内了。**
希望看到这里读者的脑袋还没有爆炸。现在，我们继续来看我们的衣场游戏。在4.6.6 节的最后，我们已经帮助妞妞确定了它的鼻子在观察空间中的位置——$(9, 8.84, -27.31)$ 。现在，我们要计算它在裁剪空间中的位置。

首先，我们需要知道衣场游戏中使用的摄像机类型。由于农场游戏是一个3D 游戏，因此这里我们使用了透视摄像机。摄像机参数和Game 视图的横纵比如胆4.42 所示。

![Untitled](Untitled%2063.png)

据此，我们可以知道透视投影的参数： FOY 为60°, Near 为5, Far 为40, Aspect 为4/3 = 1.333 。那么，对应的投影矩阵就是：

![Untitled](Untitled%2064.png)

然后，我们用这个投影矩阵来把妞妞的鼻子从观察空间转换到裁剪空间中。如下：

![Untitled](Untitled%2065.png)

这样，我们就求出了妞妞的鼻子在裁剪空间中的位置——$(11.691,15 .311,23.692,27.31)$。接下来，Unity会判断妞妞的鼻子是否需要裁剪。通过比较得到，妞妞的鼻子满足下面的不等式：

$-w≤x≤w→-27.31≤11.691≤27.31$

$-w≤y≤w→-27.31≤15.311≤27.31$

$-w≤z≤w→-27.31≤23.692≤27.31$

由此，我们可以判断，妞妞的鼻子位于视锥体内，不需要被裁剪。

## 4.6.8屏幕空间

经过投影矩阵的变换后，我们可以进行裁剪操作。当完成了所有的裁剪工作后，就需要进行真正的投影了，也就是说，我们需要把视锥体投影到**屏幕空间(screen space)** 中。经过这一步变换，我们会得到真正的像素位置，而不是虚拟的三维坐标。

屏幕空间是一个二维空间，因此，我们必须把顶点从裁剪空间投影到屏幕空间中，来生成对应的2D坐标。这个过程可以理解成有两个步骤

首先，我们需要进行**标准齐次除法(homogeneous division)**, 也被称为**透视除法(perspective division)**。虽然这个步骤听起来很陌生，但是它实际上非常简单，就是用齐次坐标系的$w$分量去除$x、y、z$分量。在OpenGL中，我们把这一步得到的坐标叫做**归一化的设备坐标(NormalizedDevice Coordinates, NDC) 。**经过这一步，我们可以把坐标从齐次栽剪坐标空间转换到NDC中。经过透视投影变换后的裁剪空间，经过齐次除法后会变换到一个立方体内。按照OpenGL的传统，这个立方体的$x、y、z$分量的范围都是$[-1, 1]$。但在DirectX这样的API中，$z$分量的范围会是$[0,1]$。而Unity选择了OpenGL这样的齐次裁剪空间，如图4.43所示。

![Untitled](Untitled%2066.png)

而对于正交投影来说，它的裁剪空间实际已经是一个立方体了，而且由于经过正交投影矩阵变换后的顶点的$w$ 分量是1, 因此齐次除法并不会对顶点的$x 、y 、z$ 坐标产生影响，如图4 .44所示。

![Untitled](Untitled%2067.png)

经过齐次除法后，透视投影和正交投影的视锥体都变换到一个相同的立方体内。现在，我们可以根据变换后的x和y坐标来映射输出窗口的对应像素坐标。

在Unity 中，屏幕空间左下角的像素坐标是$( 0, 0)$ , 右上角的像素坐标是$(pixelWidth, pixelHeight)$ 。由于当前$x$ 和$y$ 坐标都是$[- 1, 1]$, 因此这个映射的过程就是一个缩放的过程。
齐次除法和屏幕映射的过程可以使用下面的公式来总结：

$screen_x=\frac{(clip_x)\cdot(pixelWidth)}{(2)\cdot(clip_w)} + \frac{pixelWidth}{2}$

$screen_x=\frac{(clip_x)\cdot(pixelHeight)}{(2)\cdot(clip_w)} + \frac{pixelHeight}{2}$

上面的式子对$x$ 和$y$ 分量都进行了处理，那么$z$ 分量呢？通常， $z$ 分量会被用于深度缓冲。一个传统的方式是把$\frac{clip_z}{clip_w}$的值直接存进深度缓冲中，但这并不是必须的。通常驱动生产商会根据硬件来选择最好的存储格式。此时$clip_w$ 也并不会被抛弃，虽然它已经完成了它的主要工作一在齐次除法中作为分母来得到NDC, 但它仍然会在后续的一些工作中起到重要的作用，例如进行透视校正插值。

在Unity 中，从裁剪空间到屏幕空间的转换是由Unity 帮我们完成的。我们的顶点着色器只需要把顶点转换到裁剪空间即可。

在上一步中，我们知道了裁剪空间中妞妞鼻子的位置——$(11.691, 15.311, 23.692, 27.31)$ 。现在，我们终于可以确定妞妞的鼻子在屏幕上的像素位置。假设，当前屏幕的像素宽度为400, 高度为300 。首先，我们需要进行齐次除法，把裁剪空间的坐标投影到NDC 中。然后，再映射到屏幕空间中。这个过程如下：

![Untitled](Untitled%2068.png)

由此，我们知道了妞妞鼻子在屏幕上的位置——$(285 .617, 234.096)$ 。

## 4.6.9总结

以上就是一个顶点如何从模型空间变换到屏幕坐标的过程。图4.45 总结了这些空间和用于变换的矩阵。

顶点着色器的最基本的任务就是把顶点坐标从模型空间转换到裁剪空间中。这对应了图4.45中的前三个顶点变换过程。而在片元着色器中，我们通常也可以得到该片元在屏幕空间的像素位置。我们会在4.9.3 节中看到如何得到这些像素位置。

在Unity 中，坐标系的旋向性也随着变换发生了改变。图4.46 总结了Unity 中各个空间使用的坐标系旋向性。

从图4.46 中可以发现，只有在观察空间中Unity 使用了右手坐标系。
需要注意的是，这里仅仅给出的是一些最重要的坐标空间。还有一些空间在实际开发中也会遇到，例如切线空间(tangent space) 。切线空间通常用于法线映射，在后面的4.7 节中我们会讲到。

![Untitled](Untitled%2069.png)